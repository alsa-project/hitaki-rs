// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use hitaki_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AlsaFirewireError {
    Failed,
    IsOpened,
    IsNotOpened,
    IsUsed,
    IsLocked,
    IsUnlocked,
    IsDisconnected,
    WrongClass,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AlsaFirewireError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AlsaFirewireError::{}",
            match *self {
                AlsaFirewireError::Failed => "Failed",
                AlsaFirewireError::IsOpened => "IsOpened",
                AlsaFirewireError::IsNotOpened => "IsNotOpened",
                AlsaFirewireError::IsUsed => "IsUsed",
                AlsaFirewireError::IsLocked => "IsLocked",
                AlsaFirewireError::IsUnlocked => "IsUnlocked",
                AlsaFirewireError::IsDisconnected => "IsDisconnected",
                AlsaFirewireError::WrongClass => "WrongClass",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AlsaFirewireError {
    type GlibType = hitaki_sys::HitakiAlsaFirewireError;

    fn to_glib(&self) -> hitaki_sys::HitakiAlsaFirewireError {
        match *self {
            AlsaFirewireError::Failed => hitaki_sys::HITAKI_ALSA_FIREWIRE_ERROR_FAILED,
            AlsaFirewireError::IsOpened => hitaki_sys::HITAKI_ALSA_FIREWIRE_ERROR_IS_OPENED,
            AlsaFirewireError::IsNotOpened => hitaki_sys::HITAKI_ALSA_FIREWIRE_ERROR_IS_NOT_OPENED,
            AlsaFirewireError::IsUsed => hitaki_sys::HITAKI_ALSA_FIREWIRE_ERROR_IS_USED,
            AlsaFirewireError::IsLocked => hitaki_sys::HITAKI_ALSA_FIREWIRE_ERROR_IS_LOCKED,
            AlsaFirewireError::IsUnlocked => hitaki_sys::HITAKI_ALSA_FIREWIRE_ERROR_IS_UNLOCKED,
            AlsaFirewireError::IsDisconnected => {
                hitaki_sys::HITAKI_ALSA_FIREWIRE_ERROR_IS_DISCONNECTED
            }
            AlsaFirewireError::WrongClass => hitaki_sys::HITAKI_ALSA_FIREWIRE_ERROR_WRONG_CLASS,
            AlsaFirewireError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<hitaki_sys::HitakiAlsaFirewireError> for AlsaFirewireError {
    fn from_glib(value: hitaki_sys::HitakiAlsaFirewireError) -> Self {
        match value {
            0 => AlsaFirewireError::Failed,
            1 => AlsaFirewireError::IsOpened,
            2 => AlsaFirewireError::IsNotOpened,
            3 => AlsaFirewireError::IsUsed,
            4 => AlsaFirewireError::IsLocked,
            5 => AlsaFirewireError::IsUnlocked,
            6 => AlsaFirewireError::IsDisconnected,
            7 => AlsaFirewireError::WrongClass,
            value => AlsaFirewireError::__Unknown(value),
        }
    }
}

impl ErrorDomain for AlsaFirewireError {
    fn domain() -> Quark {
        unsafe { from_glib(hitaki_sys::hitaki_alsa_firewire_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(AlsaFirewireError::Failed),
            1 => Some(AlsaFirewireError::IsOpened),
            2 => Some(AlsaFirewireError::IsNotOpened),
            3 => Some(AlsaFirewireError::IsUsed),
            4 => Some(AlsaFirewireError::IsLocked),
            5 => Some(AlsaFirewireError::IsUnlocked),
            6 => Some(AlsaFirewireError::IsDisconnected),
            7 => Some(AlsaFirewireError::WrongClass),
            _ => Some(AlsaFirewireError::Failed),
        }
    }
}

impl StaticType for AlsaFirewireError {
    fn static_type() -> Type {
        unsafe { from_glib(hitaki_sys::hitaki_alsa_firewire_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AlsaFirewireError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AlsaFirewireError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AlsaFirewireError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AlsaFirewireType {
    Dice,
    Fireworks,
    Bebob,
    Oxfw,
    Digi00x,
    Tascam,
    Motu,
    Fireface,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AlsaFirewireType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AlsaFirewireType::{}",
            match *self {
                AlsaFirewireType::Dice => "Dice",
                AlsaFirewireType::Fireworks => "Fireworks",
                AlsaFirewireType::Bebob => "Bebob",
                AlsaFirewireType::Oxfw => "Oxfw",
                AlsaFirewireType::Digi00x => "Digi00x",
                AlsaFirewireType::Tascam => "Tascam",
                AlsaFirewireType::Motu => "Motu",
                AlsaFirewireType::Fireface => "Fireface",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AlsaFirewireType {
    type GlibType = hitaki_sys::HitakiAlsaFirewireType;

    fn to_glib(&self) -> hitaki_sys::HitakiAlsaFirewireType {
        match *self {
            AlsaFirewireType::Dice => hitaki_sys::HITAKI_ALSA_FIREWIRE_TYPE_DICE,
            AlsaFirewireType::Fireworks => hitaki_sys::HITAKI_ALSA_FIREWIRE_TYPE_FIREWORKS,
            AlsaFirewireType::Bebob => hitaki_sys::HITAKI_ALSA_FIREWIRE_TYPE_BEBOB,
            AlsaFirewireType::Oxfw => hitaki_sys::HITAKI_ALSA_FIREWIRE_TYPE_OXFW,
            AlsaFirewireType::Digi00x => hitaki_sys::HITAKI_ALSA_FIREWIRE_TYPE_DIGI00X,
            AlsaFirewireType::Tascam => hitaki_sys::HITAKI_ALSA_FIREWIRE_TYPE_TASCAM,
            AlsaFirewireType::Motu => hitaki_sys::HITAKI_ALSA_FIREWIRE_TYPE_MOTU,
            AlsaFirewireType::Fireface => hitaki_sys::HITAKI_ALSA_FIREWIRE_TYPE_FIREFACE,
            AlsaFirewireType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<hitaki_sys::HitakiAlsaFirewireType> for AlsaFirewireType {
    fn from_glib(value: hitaki_sys::HitakiAlsaFirewireType) -> Self {
        match value {
            1 => AlsaFirewireType::Dice,
            2 => AlsaFirewireType::Fireworks,
            3 => AlsaFirewireType::Bebob,
            4 => AlsaFirewireType::Oxfw,
            5 => AlsaFirewireType::Digi00x,
            6 => AlsaFirewireType::Tascam,
            7 => AlsaFirewireType::Motu,
            8 => AlsaFirewireType::Fireface,
            value => AlsaFirewireType::__Unknown(value),
        }
    }
}

impl StaticType for AlsaFirewireType {
    fn static_type() -> Type {
        unsafe { from_glib(hitaki_sys::hitaki_alsa_firewire_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AlsaFirewireType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AlsaFirewireType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AlsaFirewireType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum EfwProtocolError {
    Ok,
    Bad,
    BadCommand,
    CommErr,
    BadQuadCount,
    Unsupported,
    Timeout,
    DspTimeout,
    BadRate,
    BadClock,
    BadChannel,
    BadPan,
    FlashBusy,
    BadMirror,
    BadLed,
    BadParameter,
    Incomplete,
    Invalid,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EfwProtocolError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EfwProtocolError::{}",
            match *self {
                EfwProtocolError::Ok => "Ok",
                EfwProtocolError::Bad => "Bad",
                EfwProtocolError::BadCommand => "BadCommand",
                EfwProtocolError::CommErr => "CommErr",
                EfwProtocolError::BadQuadCount => "BadQuadCount",
                EfwProtocolError::Unsupported => "Unsupported",
                EfwProtocolError::Timeout => "Timeout",
                EfwProtocolError::DspTimeout => "DspTimeout",
                EfwProtocolError::BadRate => "BadRate",
                EfwProtocolError::BadClock => "BadClock",
                EfwProtocolError::BadChannel => "BadChannel",
                EfwProtocolError::BadPan => "BadPan",
                EfwProtocolError::FlashBusy => "FlashBusy",
                EfwProtocolError::BadMirror => "BadMirror",
                EfwProtocolError::BadLed => "BadLed",
                EfwProtocolError::BadParameter => "BadParameter",
                EfwProtocolError::Incomplete => "Incomplete",
                EfwProtocolError::Invalid => "Invalid",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for EfwProtocolError {
    type GlibType = hitaki_sys::HitakiEfwProtocolError;

    fn to_glib(&self) -> hitaki_sys::HitakiEfwProtocolError {
        match *self {
            EfwProtocolError::Ok => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_OK,
            EfwProtocolError::Bad => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD,
            EfwProtocolError::BadCommand => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD_COMMAND,
            EfwProtocolError::CommErr => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_COMM_ERR,
            EfwProtocolError::BadQuadCount => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD_QUAD_COUNT,
            EfwProtocolError::Unsupported => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_UNSUPPORTED,
            EfwProtocolError::Timeout => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_TIMEOUT,
            EfwProtocolError::DspTimeout => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_DSP_TIMEOUT,
            EfwProtocolError::BadRate => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD_RATE,
            EfwProtocolError::BadClock => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD_CLOCK,
            EfwProtocolError::BadChannel => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD_CHANNEL,
            EfwProtocolError::BadPan => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD_PAN,
            EfwProtocolError::FlashBusy => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_FLASH_BUSY,
            EfwProtocolError::BadMirror => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD_MIRROR,
            EfwProtocolError::BadLed => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD_LED,
            EfwProtocolError::BadParameter => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_BAD_PARAMETER,
            EfwProtocolError::Incomplete => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_INCOMPLETE,
            EfwProtocolError::Invalid => hitaki_sys::HITAKI_EFW_PROTOCOL_ERROR_INVALID,
            EfwProtocolError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<hitaki_sys::HitakiEfwProtocolError> for EfwProtocolError {
    fn from_glib(value: hitaki_sys::HitakiEfwProtocolError) -> Self {
        match value {
            0 => EfwProtocolError::Ok,
            1 => EfwProtocolError::Bad,
            2 => EfwProtocolError::BadCommand,
            3 => EfwProtocolError::CommErr,
            4 => EfwProtocolError::BadQuadCount,
            5 => EfwProtocolError::Unsupported,
            6 => EfwProtocolError::Timeout,
            7 => EfwProtocolError::DspTimeout,
            8 => EfwProtocolError::BadRate,
            9 => EfwProtocolError::BadClock,
            10 => EfwProtocolError::BadChannel,
            11 => EfwProtocolError::BadPan,
            12 => EfwProtocolError::FlashBusy,
            13 => EfwProtocolError::BadMirror,
            14 => EfwProtocolError::BadLed,
            15 => EfwProtocolError::BadParameter,
            -2147483648 => EfwProtocolError::Incomplete,
            -1 => EfwProtocolError::Invalid,
            value => EfwProtocolError::__Unknown(value),
        }
    }
}

impl ErrorDomain for EfwProtocolError {
    fn domain() -> Quark {
        unsafe { from_glib(hitaki_sys::hitaki_efw_protocol_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(EfwProtocolError::Ok),
            1 => Some(EfwProtocolError::Bad),
            2 => Some(EfwProtocolError::BadCommand),
            3 => Some(EfwProtocolError::CommErr),
            4 => Some(EfwProtocolError::BadQuadCount),
            5 => Some(EfwProtocolError::Unsupported),
            6 => Some(EfwProtocolError::Timeout),
            7 => Some(EfwProtocolError::DspTimeout),
            8 => Some(EfwProtocolError::BadRate),
            9 => Some(EfwProtocolError::BadClock),
            10 => Some(EfwProtocolError::BadChannel),
            11 => Some(EfwProtocolError::BadPan),
            12 => Some(EfwProtocolError::FlashBusy),
            13 => Some(EfwProtocolError::BadMirror),
            14 => Some(EfwProtocolError::BadLed),
            15 => Some(EfwProtocolError::BadParameter),
            -2147483648 => Some(EfwProtocolError::Incomplete),
            -1 => Some(EfwProtocolError::Invalid),
            value => Some(EfwProtocolError::__Unknown(value)),
        }
    }
}

impl StaticType for EfwProtocolError {
    fn static_type() -> Type {
        unsafe { from_glib(hitaki_sys::hitaki_efw_protocol_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for EfwProtocolError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for EfwProtocolError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for EfwProtocolError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
