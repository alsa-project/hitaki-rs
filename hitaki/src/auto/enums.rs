// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "HitakiAlsaFirewireError")]
pub enum AlsaFirewireError {
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_FAILED")]
    Failed,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_OPENED")]
    IsOpened,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_NOT_OPENED")]
    IsNotOpened,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_USED")]
    IsUsed,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_LOCKED")]
    IsLocked,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_UNLOCKED")]
    IsUnlocked,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_DISCONNECTED")]
    IsDisconnected,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_WRONG_CLASS")]
    WrongClass,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AlsaFirewireError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AlsaFirewireError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::IsOpened => "IsOpened",
                Self::IsNotOpened => "IsNotOpened",
                Self::IsUsed => "IsUsed",
                Self::IsLocked => "IsLocked",
                Self::IsUnlocked => "IsUnlocked",
                Self::IsDisconnected => "IsDisconnected",
                Self::WrongClass => "WrongClass",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for AlsaFirewireError {
    type GlibType = ffi::HitakiAlsaFirewireError;

    fn into_glib(self) -> ffi::HitakiAlsaFirewireError {
        match self {
            Self::Failed => ffi::HITAKI_ALSA_FIREWIRE_ERROR_FAILED,
            Self::IsOpened => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_OPENED,
            Self::IsNotOpened => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_NOT_OPENED,
            Self::IsUsed => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_USED,
            Self::IsLocked => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_LOCKED,
            Self::IsUnlocked => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_UNLOCKED,
            Self::IsDisconnected => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_DISCONNECTED,
            Self::WrongClass => ffi::HITAKI_ALSA_FIREWIRE_ERROR_WRONG_CLASS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::HitakiAlsaFirewireError> for AlsaFirewireError {
    unsafe fn from_glib(value: ffi::HitakiAlsaFirewireError) -> Self {
        match value {
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_FAILED => Self::Failed,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_OPENED => Self::IsOpened,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_NOT_OPENED => Self::IsNotOpened,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_USED => Self::IsUsed,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_LOCKED => Self::IsLocked,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_UNLOCKED => Self::IsUnlocked,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_DISCONNECTED => Self::IsDisconnected,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_WRONG_CLASS => Self::WrongClass,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for AlsaFirewireError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::hitaki_alsa_firewire_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_FAILED => Some(Self::Failed),
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_OPENED => Some(Self::IsOpened),
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_NOT_OPENED => Some(Self::IsNotOpened),
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_USED => Some(Self::IsUsed),
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_LOCKED => Some(Self::IsLocked),
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_UNLOCKED => Some(Self::IsUnlocked),
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_DISCONNECTED => Some(Self::IsDisconnected),
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_WRONG_CLASS => Some(Self::WrongClass),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for AlsaFirewireError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::hitaki_alsa_firewire_error_get_type()) }
    }
}

impl glib::value::ValueType for AlsaFirewireError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for AlsaFirewireError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AlsaFirewireError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "HitakiAlsaFirewireType")]
pub enum AlsaFirewireType {
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_DICE")]
    Dice,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_FIREWORKS")]
    Fireworks,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_BEBOB")]
    Bebob,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_OXFW")]
    Oxfw,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_DIGI00X")]
    Digi00x,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_TASCAM")]
    Tascam,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_MOTU")]
    Motu,
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_FIREFACE")]
    Fireface,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AlsaFirewireType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AlsaFirewireType::{}",
            match *self {
                Self::Dice => "Dice",
                Self::Fireworks => "Fireworks",
                Self::Bebob => "Bebob",
                Self::Oxfw => "Oxfw",
                Self::Digi00x => "Digi00x",
                Self::Tascam => "Tascam",
                Self::Motu => "Motu",
                Self::Fireface => "Fireface",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for AlsaFirewireType {
    type GlibType = ffi::HitakiAlsaFirewireType;

    fn into_glib(self) -> ffi::HitakiAlsaFirewireType {
        match self {
            Self::Dice => ffi::HITAKI_ALSA_FIREWIRE_TYPE_DICE,
            Self::Fireworks => ffi::HITAKI_ALSA_FIREWIRE_TYPE_FIREWORKS,
            Self::Bebob => ffi::HITAKI_ALSA_FIREWIRE_TYPE_BEBOB,
            Self::Oxfw => ffi::HITAKI_ALSA_FIREWIRE_TYPE_OXFW,
            Self::Digi00x => ffi::HITAKI_ALSA_FIREWIRE_TYPE_DIGI00X,
            Self::Tascam => ffi::HITAKI_ALSA_FIREWIRE_TYPE_TASCAM,
            Self::Motu => ffi::HITAKI_ALSA_FIREWIRE_TYPE_MOTU,
            Self::Fireface => ffi::HITAKI_ALSA_FIREWIRE_TYPE_FIREFACE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::HitakiAlsaFirewireType> for AlsaFirewireType {
    unsafe fn from_glib(value: ffi::HitakiAlsaFirewireType) -> Self {
        match value {
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_DICE => Self::Dice,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_FIREWORKS => Self::Fireworks,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_BEBOB => Self::Bebob,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_OXFW => Self::Oxfw,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_DIGI00X => Self::Digi00x,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_TASCAM => Self::Tascam,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_MOTU => Self::Motu,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_FIREFACE => Self::Fireface,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AlsaFirewireType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::hitaki_alsa_firewire_type_get_type()) }
    }
}

impl glib::value::ValueType for AlsaFirewireType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for AlsaFirewireType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AlsaFirewireType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "HitakiEfwProtocolError")]
pub enum EfwProtocolError {
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_OK")]
    Ok,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD")]
    Bad,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_COMMAND")]
    BadCommand,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_COMM_ERR")]
    CommErr,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_QUAD_COUNT")]
    BadQuadCount,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_UNSUPPORTED")]
    Unsupported,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_TIMEOUT")]
    Timeout,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_DSP_TIMEOUT")]
    DspTimeout,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_RATE")]
    BadRate,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_CLOCK")]
    BadClock,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_CHANNEL")]
    BadChannel,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_PAN")]
    BadPan,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_FLASH_BUSY")]
    FlashBusy,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_MIRROR")]
    BadMirror,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_LED")]
    BadLed,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_PARAMETER")]
    BadParameter,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_INCOMPLETE")]
    Incomplete,
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_INVALID")]
    Invalid,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EfwProtocolError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EfwProtocolError::{}",
            match *self {
                Self::Ok => "Ok",
                Self::Bad => "Bad",
                Self::BadCommand => "BadCommand",
                Self::CommErr => "CommErr",
                Self::BadQuadCount => "BadQuadCount",
                Self::Unsupported => "Unsupported",
                Self::Timeout => "Timeout",
                Self::DspTimeout => "DspTimeout",
                Self::BadRate => "BadRate",
                Self::BadClock => "BadClock",
                Self::BadChannel => "BadChannel",
                Self::BadPan => "BadPan",
                Self::FlashBusy => "FlashBusy",
                Self::BadMirror => "BadMirror",
                Self::BadLed => "BadLed",
                Self::BadParameter => "BadParameter",
                Self::Incomplete => "Incomplete",
                Self::Invalid => "Invalid",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for EfwProtocolError {
    type GlibType = ffi::HitakiEfwProtocolError;

    fn into_glib(self) -> ffi::HitakiEfwProtocolError {
        match self {
            Self::Ok => ffi::HITAKI_EFW_PROTOCOL_ERROR_OK,
            Self::Bad => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD,
            Self::BadCommand => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_COMMAND,
            Self::CommErr => ffi::HITAKI_EFW_PROTOCOL_ERROR_COMM_ERR,
            Self::BadQuadCount => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_QUAD_COUNT,
            Self::Unsupported => ffi::HITAKI_EFW_PROTOCOL_ERROR_UNSUPPORTED,
            Self::Timeout => ffi::HITAKI_EFW_PROTOCOL_ERROR_TIMEOUT,
            Self::DspTimeout => ffi::HITAKI_EFW_PROTOCOL_ERROR_DSP_TIMEOUT,
            Self::BadRate => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_RATE,
            Self::BadClock => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CLOCK,
            Self::BadChannel => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CHANNEL,
            Self::BadPan => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PAN,
            Self::FlashBusy => ffi::HITAKI_EFW_PROTOCOL_ERROR_FLASH_BUSY,
            Self::BadMirror => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_MIRROR,
            Self::BadLed => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_LED,
            Self::BadParameter => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PARAMETER,
            Self::Incomplete => ffi::HITAKI_EFW_PROTOCOL_ERROR_INCOMPLETE,
            Self::Invalid => ffi::HITAKI_EFW_PROTOCOL_ERROR_INVALID,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::HitakiEfwProtocolError> for EfwProtocolError {
    unsafe fn from_glib(value: ffi::HitakiEfwProtocolError) -> Self {
        match value {
            ffi::HITAKI_EFW_PROTOCOL_ERROR_OK => Self::Ok,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD => Self::Bad,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_COMMAND => Self::BadCommand,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_COMM_ERR => Self::CommErr,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_QUAD_COUNT => Self::BadQuadCount,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_UNSUPPORTED => Self::Unsupported,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_TIMEOUT => Self::Timeout,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_DSP_TIMEOUT => Self::DspTimeout,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_RATE => Self::BadRate,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CLOCK => Self::BadClock,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CHANNEL => Self::BadChannel,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PAN => Self::BadPan,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_FLASH_BUSY => Self::FlashBusy,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_MIRROR => Self::BadMirror,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_LED => Self::BadLed,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PARAMETER => Self::BadParameter,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_INCOMPLETE => Self::Incomplete,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_INVALID => Self::Invalid,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for EfwProtocolError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::hitaki_efw_protocol_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::HITAKI_EFW_PROTOCOL_ERROR_OK => Some(Self::Ok),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD => Some(Self::Bad),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_COMMAND => Some(Self::BadCommand),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_COMM_ERR => Some(Self::CommErr),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_QUAD_COUNT => Some(Self::BadQuadCount),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_UNSUPPORTED => Some(Self::Unsupported),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_TIMEOUT => Some(Self::Timeout),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_DSP_TIMEOUT => Some(Self::DspTimeout),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_RATE => Some(Self::BadRate),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CLOCK => Some(Self::BadClock),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CHANNEL => Some(Self::BadChannel),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PAN => Some(Self::BadPan),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_FLASH_BUSY => Some(Self::FlashBusy),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_MIRROR => Some(Self::BadMirror),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_LED => Some(Self::BadLed),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PARAMETER => Some(Self::BadParameter),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_INCOMPLETE => Some(Self::Incomplete),
            ffi::HITAKI_EFW_PROTOCOL_ERROR_INVALID => Some(Self::Invalid),
            value => Some(Self::__Unknown(value)),
        }
    }
}

impl StaticType for EfwProtocolError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::hitaki_efw_protocol_error_get_type()) }
    }
}

impl glib::value::ValueType for EfwProtocolError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for EfwProtocolError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for EfwProtocolError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
