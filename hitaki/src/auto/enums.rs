// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::{prelude::*, translate::*};

/// The enumerations to report result of operation in [`AlsaFirewire`][crate::AlsaFirewire].
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "HitakiAlsaFirewireError")]
pub enum AlsaFirewireError {
    /// The system call fails.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_FAILED")]
    Failed,
    /// The instance is already associated to any ALSA HwDep character device.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_OPENED")]
    IsOpened,
    /// The instance is not associated to any ALSA HwDep character device yet.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_NOT_OPENED")]
    IsNotOpened,
    /// The ALSA HwDep character device is used by the other process.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_USED")]
    IsUsed,
    /// The functionality of packet streaming is prohibited.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_LOCKED")]
    IsLocked,
    /// The functionality of packet streaming is available.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_UNLOCKED")]
    IsUnlocked,
    /// The sound card is disconnected.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_IS_DISCONNECTED")]
    IsDisconnected,
    /// Mismatch between GObject class and thetype of sound unit.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_ERROR_WRONG_CLASS")]
    WrongClass,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AlsaFirewireError {
    type GlibType = ffi::HitakiAlsaFirewireError;

    #[inline]
    fn into_glib(self) -> ffi::HitakiAlsaFirewireError {
        match self {
            Self::Failed => ffi::HITAKI_ALSA_FIREWIRE_ERROR_FAILED,
            Self::IsOpened => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_OPENED,
            Self::IsNotOpened => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_NOT_OPENED,
            Self::IsUsed => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_USED,
            Self::IsLocked => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_LOCKED,
            Self::IsUnlocked => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_UNLOCKED,
            Self::IsDisconnected => ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_DISCONNECTED,
            Self::WrongClass => ffi::HITAKI_ALSA_FIREWIRE_ERROR_WRONG_CLASS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::HitakiAlsaFirewireError> for AlsaFirewireError {
    #[inline]
    unsafe fn from_glib(value: ffi::HitakiAlsaFirewireError) -> Self {
        match value {
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_FAILED => Self::Failed,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_OPENED => Self::IsOpened,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_NOT_OPENED => Self::IsNotOpened,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_USED => Self::IsUsed,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_LOCKED => Self::IsLocked,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_UNLOCKED => Self::IsUnlocked,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_IS_DISCONNECTED => Self::IsDisconnected,
            ffi::HITAKI_ALSA_FIREWIRE_ERROR_WRONG_CLASS => Self::WrongClass,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for AlsaFirewireError {
    #[inline]
    fn domain() -> glib::Quark {
        unsafe { from_glib(ffi::hitaki_alsa_firewire_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for AlsaFirewireError {
    #[inline]
    #[doc(alias = "hitaki_alsa_firewire_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::hitaki_alsa_firewire_error_get_type()) }
    }
}

impl glib::HasParamSpec for AlsaFirewireError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AlsaFirewireError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AlsaFirewireError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AlsaFirewireError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AlsaFirewireError> for glib::Value {
    #[inline]
    fn from(v: AlsaFirewireError) -> Self {
        ToValue::to_value(&v)
    }
}

/// The enumerations for type of sound unit defined by ALSA firewire stack.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "HitakiAlsaFirewireType")]
pub enum AlsaFirewireType {
    /// The type of DICE ASIC.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_DICE")]
    Dice,
    /// The type of Fireworks board module.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_FIREWORKS")]
    Fireworks,
    /// The type of BeBoB ASIC.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_BEBOB")]
    Bebob,
    /// The type of OXFW ASIC
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_OXFW")]
    Oxfw,
    /// The type of Digi00x series.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_DIGI00X")]
    Digi00x,
    /// The type of Tascam FireWire series.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_TASCAM")]
    Tascam,
    /// The type of MOTU FireWire series.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_MOTU")]
    Motu,
    /// The type of RME Fireface series.
    #[doc(alias = "HITAKI_ALSA_FIREWIRE_TYPE_FIREFACE")]
    Fireface,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AlsaFirewireType {
    type GlibType = ffi::HitakiAlsaFirewireType;

    #[inline]
    fn into_glib(self) -> ffi::HitakiAlsaFirewireType {
        match self {
            Self::Dice => ffi::HITAKI_ALSA_FIREWIRE_TYPE_DICE,
            Self::Fireworks => ffi::HITAKI_ALSA_FIREWIRE_TYPE_FIREWORKS,
            Self::Bebob => ffi::HITAKI_ALSA_FIREWIRE_TYPE_BEBOB,
            Self::Oxfw => ffi::HITAKI_ALSA_FIREWIRE_TYPE_OXFW,
            Self::Digi00x => ffi::HITAKI_ALSA_FIREWIRE_TYPE_DIGI00X,
            Self::Tascam => ffi::HITAKI_ALSA_FIREWIRE_TYPE_TASCAM,
            Self::Motu => ffi::HITAKI_ALSA_FIREWIRE_TYPE_MOTU,
            Self::Fireface => ffi::HITAKI_ALSA_FIREWIRE_TYPE_FIREFACE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::HitakiAlsaFirewireType> for AlsaFirewireType {
    #[inline]
    unsafe fn from_glib(value: ffi::HitakiAlsaFirewireType) -> Self {
        match value {
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_DICE => Self::Dice,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_FIREWORKS => Self::Fireworks,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_BEBOB => Self::Bebob,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_OXFW => Self::Oxfw,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_DIGI00X => Self::Digi00x,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_TASCAM => Self::Tascam,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_MOTU => Self::Motu,
            ffi::HITAKI_ALSA_FIREWIRE_TYPE_FIREFACE => Self::Fireface,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AlsaFirewireType {
    #[inline]
    #[doc(alias = "hitaki_alsa_firewire_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::hitaki_alsa_firewire_type_get_type()) }
    }
}

impl glib::HasParamSpec for AlsaFirewireType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AlsaFirewireType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AlsaFirewireType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AlsaFirewireType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AlsaFirewireType> for glib::Value {
    #[inline]
    fn from(v: AlsaFirewireType) -> Self {
        ToValue::to_value(&v)
    }
}

/// The enumerations to report status of response in Fireworks protocol.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "HitakiEfwProtocolError")]
pub enum EfwProtocolError {
    /// The transaction finished successfully.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_OK")]
    Ok,
    /// The request or response includes invalid header.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD")]
    Bad,
    /// The request includes invalid category or command.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_COMMAND")]
    BadCommand,
    /// The transaction fails due to communication error.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_COMM_ERR")]
    CommErr,
    /// The number of quadlets in transaction is invalid.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_QUAD_COUNT")]
    BadQuadCount,
    /// The request is not supported.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_UNSUPPORTED")]
    Unsupported,
    /// The transaction is canceled due to response timeout.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_TIMEOUT")]
    Timeout,
    /// The operation for DSP did not finish within timeout.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_DSP_TIMEOUT")]
    DspTimeout,
    /// The request includes invalid value for sampling frequency.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_RATE")]
    BadRate,
    /// The request includes invalid value for source of clock.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_CLOCK")]
    BadClock,
    /// The request includes invalid value for the number of channel.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_CHANNEL")]
    BadChannel,
    /// The request includes invalid value for panning.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_PAN")]
    BadPan,
    /// The on-board flash is busy and not operable.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_FLASH_BUSY")]
    FlashBusy,
    /// The request includes invalid value for mirroring channel.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_MIRROR")]
    BadMirror,
    /// The request includes invalid value for LED.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_LED")]
    BadLed,
    /// The request includes invalid value of parameter.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_BAD_PARAMETER")]
    BadParameter,
    /// The transaction finishes incompletely.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_INCOMPLETE")]
    Incomplete,
    /// The transaction finished with invalid condition.
    #[doc(alias = "HITAKI_EFW_PROTOCOL_ERROR_INVALID")]
    Invalid,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for EfwProtocolError {
    type GlibType = ffi::HitakiEfwProtocolError;

    fn into_glib(self) -> ffi::HitakiEfwProtocolError {
        match self {
            Self::Ok => ffi::HITAKI_EFW_PROTOCOL_ERROR_OK,
            Self::Bad => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD,
            Self::BadCommand => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_COMMAND,
            Self::CommErr => ffi::HITAKI_EFW_PROTOCOL_ERROR_COMM_ERR,
            Self::BadQuadCount => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_QUAD_COUNT,
            Self::Unsupported => ffi::HITAKI_EFW_PROTOCOL_ERROR_UNSUPPORTED,
            Self::Timeout => ffi::HITAKI_EFW_PROTOCOL_ERROR_TIMEOUT,
            Self::DspTimeout => ffi::HITAKI_EFW_PROTOCOL_ERROR_DSP_TIMEOUT,
            Self::BadRate => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_RATE,
            Self::BadClock => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CLOCK,
            Self::BadChannel => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CHANNEL,
            Self::BadPan => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PAN,
            Self::FlashBusy => ffi::HITAKI_EFW_PROTOCOL_ERROR_FLASH_BUSY,
            Self::BadMirror => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_MIRROR,
            Self::BadLed => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_LED,
            Self::BadParameter => ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PARAMETER,
            Self::Incomplete => ffi::HITAKI_EFW_PROTOCOL_ERROR_INCOMPLETE,
            Self::Invalid => ffi::HITAKI_EFW_PROTOCOL_ERROR_INVALID,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::HitakiEfwProtocolError> for EfwProtocolError {
    unsafe fn from_glib(value: ffi::HitakiEfwProtocolError) -> Self {
        match value {
            ffi::HITAKI_EFW_PROTOCOL_ERROR_OK => Self::Ok,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD => Self::Bad,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_COMMAND => Self::BadCommand,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_COMM_ERR => Self::CommErr,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_QUAD_COUNT => Self::BadQuadCount,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_UNSUPPORTED => Self::Unsupported,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_TIMEOUT => Self::Timeout,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_DSP_TIMEOUT => Self::DspTimeout,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_RATE => Self::BadRate,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CLOCK => Self::BadClock,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_CHANNEL => Self::BadChannel,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PAN => Self::BadPan,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_FLASH_BUSY => Self::FlashBusy,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_MIRROR => Self::BadMirror,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_LED => Self::BadLed,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_BAD_PARAMETER => Self::BadParameter,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_INCOMPLETE => Self::Incomplete,
            ffi::HITAKI_EFW_PROTOCOL_ERROR_INVALID => Self::Invalid,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for EfwProtocolError {
    #[inline]
    fn domain() -> glib::Quark {
        unsafe { from_glib(ffi::hitaki_efw_protocol_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for EfwProtocolError {
    #[inline]
    #[doc(alias = "hitaki_efw_protocol_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::hitaki_efw_protocol_error_get_type()) }
    }
}

impl glib::HasParamSpec for EfwProtocolError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for EfwProtocolError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for EfwProtocolError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for EfwProtocolError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<EfwProtocolError> for glib::Value {
    #[inline]
    fn from(v: EfwProtocolError) -> Self {
        ToValue::to_value(&v)
    }
}
